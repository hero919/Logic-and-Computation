#|

CS 2800 Homework 4 - Fall 2014

Student names: This homework is done in pairs. Put BOTH names here.

For this homework you will need to use ACL2s.

Technical instructions:

- open this file in ACL2s as hw04.lisp

- make sure you are in BEGINNERS mode. As far as our class is concerned,
  this mode differs from Bare Bones mode (which we have used so far) in
  that most functions you "expect" are built-in, including all common
  recognizers, Booleans, arithmetic functions, and list processing
  functions, greatly faciliating programming.

  It also differs in the way it treats the Booleans: functions like 'and'
  and 'or' can now take any number of arguments, including zero or one:

  [[(and nil t t)]] = nil  , [[(or t)]] = t

  They can even take non-Boolean arguments. However, when called on Boolean
  argumetns, 'and' and 'or' behave as in propositional logic.

  BEGINNERS is essential for this homework! Note that you can only change
  the mode when the session is not running, so that the correct mode before
  starting the session.

- insert your solutions into this file where indicated (usually as "...")

- only add to the file. Do not remove or comment out anything pre-existing.

- make sure the entire file is accepted by ACL2s. In particular, there must
  be no "..." left in the code. If you don't finish some problems, comment
  them out. The same is true for any English text that you may add. This
  file already contains many comments, so you can see what the syntax is.

Instructions for programming problems:

For each function definition, you must provide both contracts and a body.

You must also ALWAYS supply your own tests. This is in addition to the
tests sometimes provided. Make sure you produce sufficiently many new test
cases. This means: cover at least the possible scenarios according to the
data definitions of the involved types. For example, a function taking two
lists should have at least 4 tests: all combinations of each list being
empty and non-empty.

Beyond that, the number of tests should reflect the difficulty of the
function. For very simple ones, the above coverage of the data definition
cases may be sufficient. For complex functions with numerical output, you
want to test whether it produces the correct output on a reasonable
number if inputs.

Use good judgment. For unreasonably few test cases we will deduct points.

We will use ACL2s' check= facility for tests. This function is similar to
the equal function, except that if the evaluations of the two arguments
passed to it are not equal, the function call results in an error message
(rather than returning nil, as in the case of equal). Thus, if any call to
check= results in "not equal", your file will be rejected.

- when done, save your file and submit it as hw04.lisp.

- avoid submitting the session file (which shows your interaction with the
  theorem prover). This is not part of your solution.

|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Encryption using XOR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|

The Boolean xor function can be used to implement a simple
encryption/decryption scheme. In this homework you are asked to implement
that scheme and put an ASCII-like encoder/decoder on top of that, so that
you can encrypt actual English sentences, not just sequences of bits.

|#

;; Data definitions for lists of booleans, symbols, letters:

(defdata booleanlist (listof boolean))
(defdata symbollist  (listof symbol))
(defdata letterlist  (enum '(a b c d e f g h i j k l m n o p q r s t u v w x y z)))

#|

The definition of the letterlist enumeration type automatically gives rise
to a list representation of the elements of the type, via the constant
*letterlist-values*

For example:

|#

(check= *letterlist-values* '(a b c d e f g h i j k l m n o p q r s t u v w x y z))

;;; Auxiliary functions ;;;

;; Define the following simple functions in ACL2. To avoid confusion,
;; contracts are provided.

;; Prefix of l of length n. If l doesn't have n elements, return l
(defunc prefix (l n)
  :input-contract (and (listp l) (natp n))
  :output-contract (listp (prefix l n))
  (if (or (endp l) (equal n 0))
    nil
    (cons (first l) (prefix (rest l) (- n 1)))))

(check= (prefix '(1 2 3) 2) '(1 2))
(check= (prefix '(1 2 3) 4) '(1 2 3))

; position of x in l (counting from 0) if x occurs in l, (len l) otherwise
(defunc pos (x l)
  :input-contract (listp l)
  :output-contract (natp (pos x l))
  (if (or (endp l)
          (equal x (first l)))
    0
    (+ 1 (pos x (rest l)))))

(check= (pos 'c *letterlist-values*) 2)
(check= (pos '@ *letterlist-values*) (len *letterlist-values*))

; n raised to power e. We define 0^0 = 1
(defunc power (n e)
  :input-contract (and (natp n) (natp e))
  :output-contract (natp (power n e))
  (if (equal e 0)
    1
    (* n (power n (- e 1)))))

(check= (power 3 1) 3)
(check= (power 3 3) 27)

; The following directive turns off some static checks that ACL2 performs.
; We turn them off for the rest of this homework since some of these checks
; are non-trivial and may require advanced features of ACL2 that we have
; not studied.

:program

;; We will implement our encoding scheme in three steps: (i) functions to
;; encrypt "sentences" into boolean lists, (ii) functions to decrypt boolean
;; lists into "sentences", and (iii) the actual encryption scheme, using
;; xor.

;;; Conversion from sentences to boolean lists ;;;

; Function that converts symbols to a simplified ASCII code. Your function
; takes an arbitrary symbol as input and returns 0..25 if the symbol is a
; letter, 26 otherwise. See tests below.

; symbol2dec : Symbol -> Nat

; Hint: this is a one-liner. Use the pos function defined above
; and *letterlist-values*.

(defunc symbol2dec (s)
  :input-contract (symbolp s)
  :output-contract (natp (symbol2dec s))
  (pos s *letterlist-values*))

(check= (symbol2dec 'z) 25) ; the quote expression 'z returns the symbol z: [['z]] = z
(check= (symbol2dec '@) 26) ; ditto

; Function that converts a natural number n to a boolean list, as follows.
; If n >= 26, return nil. Otherwise, return the binary representation of n,
; where we interpret nil as 0 and t as 1. Leading zeros must be included as
; leading nil's in the result! See tests below.

; dec2booleanlist : Nat -> Booleanlist

; Since 2^5 = 32 > 26, the result is going to be a boolean list of length
; exactly 5. What is the condition for the left-most (highest-order) bit to
; be 1?

; In the stub below, some of the code is given to you to get you started.
; Make sure you understand the existing code. Then fill in the rest.

; The form 'let*' is used to define local variables. If you don't know this
; form, use any Lisp book or online documentation to find out about it, e.g.

; http://www.lispworks.com/documentation/HyperSpec/Body/s_let_l.htm

(defunc dec2booleanlist (n)
  :input-contract (natp n)
  :output-contract (booleanlistp (dec2booleanlist n))
  (if (< n 26)
    (let* ((d4 (>= n 16))
           (n  (if d4 (- n 16) n))
           (d3 (>= n  8))
           (n  (if d3 (- n  8) n))
           (d2 (>= n  4))
           (n  (if d2 (- n  4) n))
           (d1 (>= n  2))
           (n  (if d1 (- n  2) n))
           (d0 (>= n  1)))
      (list d4 d3 d2 d1 d0))
    nil))

(check= (dec2booleanlist  8) '(nil t nil nil nil)) ; 8 = 01000. Do not skip leading nil's (zeros): the output MUST be a list of length 5.
(check= (dec2booleanlist 32) nil)
(check= (dec2booleanlist 17) '(t nil nil nil t))

; Function that converts a symbol s into a boolean list. First convert s
; into a decimal number using a function defined previously, then convert
; that into boolean list using a function defined previously. No recursion.

; symbol2booleanlist : Symbol -> Booleanlist

(defunc symbol2booleanlist (s)
  :input-contract (symbolp s)
  :output-contract (booleanlistp (symbol2booleanlist s))
  (dec2booleanlist (symbol2dec s)))

(check= (symbol2booleanlist 'f) '(nil nil t nil t))
(check= (symbol2booleanlist 'z) '(t t nil nil t))

; Function that converts a symbol list sl into a boolean list. See the
; tests below: the result must be the _concatenation_ (use append) of all
; boolean lists obtained by converting the symbols in sl into boolean
; lists.

; symbollist2booleanlist : Symbollist -> Booleanlist

(defunc symbollist2booleanlist (sl)
  :input-contract (symbollistp sl)
  :output-contract (booleanlistp (symbollist2booleanlist sl))
  (if (endp sl)
    nil
    (append (symbol2booleanlist (first sl))
            (symbollist2booleanlist (rest sl)))))

; Notice that you must put spaces between symbols, but the number
; of spaces are irrelevant.
(check= (symbollist2booleanlist '(i   a m    s a m))
        '(NIL T NIL NIL NIL   ;i
          NIL NIL NIL NIL NIL ;a
          NIL T T NIL NIL     ;m
          T NIL NIL T NIL     ;s
          NIL NIL NIL NIL NIL ;a
          NIL T T NIL NIL))   ;m

;;; Conversion from booleanlist to symbollist ;;;

; Function that takes a boolean list (any length), interprets nil as 0 and
; t as 1 and the list as a number in binary representation. Output is the
; decimal value of the number. Hint: use power!

; booleanlist2dec : Booleanlist -> Nat

(defunc booleanlist2dec (l)
  :input-contract (booleanlistp l)
  :output-contract (natp (booleanlist2dec l))
  (if (endp l)
    0
    (+ (if (first l)
         (power 2 (- (len l) 1))
         0)
       (booleanlist2dec (rest l)))))

(check= (booleanlist2dec '(t t nil t)) 13)
(check= (booleanlist2dec '(t t nil t t nil t nil t)) 437)

; Function that takes a decimal number dec. If dec >= 26, return the
; symbol - (dash). Otherwise, return the dec'th letter of the alphabet (counting
; starts from 0).

; Hint: use *letterlist-values* and nth.

; dec2symbol : Nat -> Symbol

(defunc dec2symbol (dec)
  :input-contract (natp dec)
  :output-contract (symbolp (dec2symbol dec))
  (if (< dec 26)
      (nth dec *letterlist-values*)
      '-))

(check= (dec2symbol  0) 'a)
(check= (dec2symbol 10) 'k)

; Function that converts a boolean list to a symbol. First convert the
; boolean list into a decimal number, then convert that into a symbol. All
; using previously defined functions.

; booleanlist2symbol : Booleanlist -> Symbol

(defunc booleanlist2symbol (l)
  :input-contract (booleanlistp l)
  :output-contract (symbolp (booleanlist2symbol l))
  (dec2symbol (booleanlist2dec l)))

(check= (booleanlist2symbol '(nil t nil t nil)) 'k) ; 01010 (bin) = 10 (dec), 10th letter = k

; Function that converts a boolean list into a symbol list. This function
; takes the first 5 booleans in the lists, interprets them as a binary
; number and converts them into a symbol, using previously defined
; functions. Then the function takes the next 5 booleans in the list, and
; so on. The result must be the list of all symbols obtained this
; way.

; Hint: use nthrest: (nthrest n l) applies rest to l n times, e.g.,
; (nthrest 0 '(1 2 3)) = (1 2 3) and (nthrest 2 '(1 2 3)) = (3)

; booleanlist2symbollist : Booleanlist -> Symbollist

(defunc booleanlist2symbollist (l)
  :input-contract (booleanlistp l)
  :output-contract (symbollistp (booleanlist2symbollist l))
  (if (< (len l) 5) ; each group of 5 booleans represents a symbol 
    nil
    (cons (booleanlist2symbol (prefix l 5))
          (booleanlist2symbollist (nthrest 5 l)))))

(check= (booleanlist2symbollist '(nil nil nil nil nil nil nil nil nil t nil nil nil t nil)) '(a b c))


;;; Now the Encoding and Decoding ;;;

; Remember the xor function:
(defunc xor (a b)
  :input-contract (and (booleanp a) (booleanp b))
  :output-contract (booleanp (xor a b))
  (not (iff a b)))

;; bitwise xor. This function takes two boolean lists and xor's
;; corresponding elements. If one of the lists has fewer elements than the
;; other, assume nil for the missing elements; see tests below

; bitwise-xor : Booleanlist x Booleanlist -> Booleanlist

(defunc bitwise-xor (l1 l2)
  :input-contract (and (booleanlistp l1) (booleanlistp l2))
  :output-contract (booleanlistp (bitwise-xor l1 l2))
  (cond ((and (endp l1) (endp l2)) nil)
        ((endp l1)      (cons (xor nil        (first l2)) (bitwise-xor nil       (rest l2))))
        ((endp l2)      (cons (xor (first l1) nil)        (bitwise-xor (rest l1) nil)))
        (t              (cons (xor (first l1) (first l2)) (bitwise-xor (rest l1) (rest l2))))))

(check= (bitwise-xor '(nil t t) '(t nil nil)) '(t t t))
(check= (bitwise-xor '(nil t t) '(t nil))     '(t t t)) ; same as previous, by convention


; The idea of our encryption scheme is as follows. Show that the formula

; x <> k <> k

; can be simplified to x. What does this result mean? When you "xor" a
; given value x against a "key" k twice, you get x back. So the same key
; can be used to encrypt x AND to later decrypt the scrambled message to
; recover x.

; Our encryption scheme is thus based on bitwise xor-ing the input message
; (after translating it into a bitstring) against a key that only the
; intended communicators know. To decrypt, we apply the key again.

; We first need to define such a key.

; Replace the boolean list below with your own secret key if you like. Make
; sure it is at least a few dozen booleans long: the shorter, the weaker
; the encryption mechanism, since keys shorter than the message will be
; filled up with nil (which is easy to guess and exploit by an attacker).

:logic ; ignore but do not remove this line

(defdata key (enum
              '(  t nil t t nil t nil nil nil t t nil nil
                    nil t nil t t nil t nil t nil t t nil t nil
                    t t nil t nil nil t nil t t nil t t t nil nil
                    nil t t nil t nil t nil t t nil nil t nil t)))

:program ; ignore but do not remove this line

; Note that key is an explicit enumeration of boolean values. You can
; get access to those values in the form of a list using the constant
; expression

;  *key-values*

; for instance:

(check= (listp *key-values*) T)


; Function to encrypt a message. A "message" is a list of symbols. Convert
; that list into a boolean list, then encrypt the result against the secret
; key, i.e. apply the bit-wise xor to the result and your secret key:

; encrypt : Symbollist -> Booleanlist

(defunc encrypt (message)
  :input-contract (symbollistp message)
  :output-contract (booleanlistp (encrypt message))
  (bitwise-xor (symbollist2booleanlist message) *key-values*))

; The result of this function depends on your choice of key. Show the
; output of this function on a few test cases.

; Function that decrypts an encrypted message. An "encrypted message" is a
; list of booleans. xor that list bitwise against the secret key, and convert
; the result into a list of symbols.

; decrypt : Booleanlist -> Symbollist

(defunc decrypt (cryptic-message)
  :input-contract (booleanlistp cryptic-message)
  :output-contract (symbollistp (decrypt cryptic-message))
  (booleanlist2symbollist (bitwise-xor cryptic-message *key-values*)))

; The result of this function depends on your choice of key. Show the
; output of this function on a few test cases.

; Now test whether encryption followed by decryption reproduces the
; original message. The following test will pass with the key defined
; above.

(check=
 (let ((m '(m e e t     y o u     u n d e r     t h e     b r i d g e)))
   (equal (decrypt (encrypt m))
          m))
 t)

; Does decrypting the encrypted message always reproduce the original? Or
; can you think of cases (without contract violation) where the
; encryption and decryption are not inverses of each other? Create such an
; example in the test below (note: we check= against nil, not against t):

(check=
 (let ((m '(t o o     s h o r t)))
   (equal (decrypt (encrypt m))
          m))
 nil)

; Hint: here is how you can get more output for a failing check= : in
; addition to the info that it failed, it prints the two (non-equal) values.
; The example below will fail and is thus placed in comments.

#|

(acl2::without-evisc
 (check= 1 t))

|#
