#|

CS 2800 Homework 7 - Fall 2014

Student names: This homework is done in pairs. Put BOTH names here.

Technical instructions:

- open this file in ACL2s BEGINNER mode as hw07.lisp

- insert your solutions into this file where indicated (usually as "...")

- only add to the file. Do not remove or comment out anything pre-existing.

- make sure the entire file is accepted by ACL2s. In particular, there must
  be no "..." left in the code. If you don't finish some problems, comment
  them out. The same is true for any English text that you may add. This
  file already contains many comments, so you can see what the syntax is.

- when done, save your file and submit it as hw07.lisp.

- avoid submitting the session file (which shows your interaction with the
  theorem prover). This is not part of your solution.

|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 1. Conjecture contract checking
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|

The following conjectures are incomplete (irrespective of whether they are
true or false): they are lacking hypotheses that make sure the functions
involved are called only on arguments that satisfy the functions' input
contracts. Make the conjectures meaningful by adding the necessary contract
hypotheses. For example, given a conjecture c, if you think hypotheses h1
and h2 (and nothing else) are necessary to ensure the input contracts of
all functions occurring in c are satisfied, your solution should be

h1 /\ h2 => c

Simplify the conjecture hypotheses as much as possible. In the above
example, suppose h1 => h2 is valid. Then the conjunction h1 /\ h2 is
equivalent to h1 ; thus, simplify your output to

h1 => c

The examples below may contain some functions for which we only know the
signature, and known functions such as + . The input contracts of _all_
functions need to be ensured by the hypotheses.

(a) Given

foo: List x List -> List
bar:  All x List -> List

the conjecture c is

  (foo (bar (+ x y) l) z)   =   (bar (+ y x) (foo l z))

Conjecture with hypotheses:

(rationalp x) /\ (rationalp y) /\ (listp l) /\ (listp z) => c

(b) Consider the following two definitions, the first of which gives rise
to a recognizer natlistp:

|#

(defdata natlist (listof nat))

(defunc evenlistp (l)
  :input-contract t
  :output-contract (booleanp (evenlistp l))
  (if (listp l)
    (integerp (/ (len l) 2))
    nil))

#|

Given

d: List -> All
m: Nat x List -> NatList
f: List -> Nat
s: EvenList -> List

the conjecture c is

(d (m x l)) = (f (s l))

Conjecture with hypotheses:

(natp x) /\ (listp l) /\ (evenlistp l) => c , which is equivalent to
(natp x) /\ (evenlistp l) => c

Now define four functions d, m, f, s (as simple as possible) with the above
signatures. The actual outputs of the functions are arbitrary, as long as
they satisfy the output contract.

|#

(defunc d (l)
  :input-contract (listp l)
  :output-contract t
  nil)

(defunc m (n l)
  :input-contract (and (natp n) (listp l))
  :output-contract (natlistp (m n l))
  nil)

(defunc f (l)
  :input-contract (listp l)
  :output-contract (natp (f l))
  0)

(defunc s (l)
  :input-contract (evenlistp l)
  :output-contract (listp (s l))
  nil)

; Suppose we want to write a function that tests our conjecture:

(defunc dummy (x l)
  :input-contract (and (natp x) (evenlistp l))
  :output-contract (booleanp (dummy x l))
  (equal (d (m x l)) (f (s l))))

#|

Complete the function definition. That is, replace the first ... with the
hypotheses you found, and the second ... with an appropriate output
contract. Make sure this definition is accepted by ACL2! Test this function
on at least one input.

|#

(check= (dummy 3 '(1 2 3 4))
	nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 2. Equational reasoning
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|

Instructions:

- perform conjecture contract checking, and add hypotheses if necessary

- run some tests to make an educated guess as to whether the conjecture is
  true or false. In the latter case, find a counterexample to the
  conjecture. In the former case, continues as below.

- use propositional reasoning to rewrite the conjecture into an implication
  with a conjunction of hypotheses in the antecedent and a single
  expression in the conclusion. If that is not possible, you may have to
  split the proof into several parts such that each part can be rewritten
  into such an implication.

- for each implication, extract the context (the hypotheses), and determine
  the derived context: anything that follows immediately from the context
  expressions and may be useful later.

- now perform the proof.

When writing your equational reasoning proofs be sure to justify each step
in the style shown in class, eg.

  (len ())
= { def len }
  0

You can use basic arithmetic facts for free, but in the justification write
"arithmetic", e.g.,

  (first x) + (len (rest x)) + (sum y) + 0
= { Arithmetic }
  (sum y) + (first x) + (len (rest x))

You may use infix notation like x+y+z for arithmetic operators (as done
above), instead of the LISP style prefix notation like (+ x (+ y z)).

You can of course also use previously (in class or in homework) proved
theorems. In this case, cite the theorem in the justification, and give the
substitution that shows how you instantiated the theorem.

Here are the definitions used for the remainder of the questions. (Note:
these may be different from earlier definitions of these functions -- what
counts are the definitions provided here.)

(defunc atom (x)
  :input-contract t
  :output-contract (booleanp (atom x))
  (not (consp a)))

(defunc endp (a)
  :input-contract (listp a)
  :output-contract (booleanp (endp a))
  (not (consp a)))

(defunc listp (l)
  :input-contract t
  :output-contract (booleanp (listp l))
  (or (endp l) (consp l)))

(defunc len (x)
  :input-contract (listp l)
  :output-contract (natp (len x))
  (if (endp x)
      0
    (+ 1 (len (rest x)))))

(defunc twice (l)
  :input-contract (listp l)
  :output-contract (listp (twice l))
  (if (endp l)
    nil
    (cons (first l) (cons (first l) (twice (rest l))))))

(defunc app (a b)
  :input-contract (and (listp a) (listp b))
  :output-contract (and (listp (app a b))
                        (equal (len (app a b))
                               (+ (len a) (len b))))
  (if (endp a)
    b
    (cons (first a) (app (rest a) b))))

(defunc rev (x)
  :input-contract (listp x)
  :output-contract (and (listp (rev x))
                        (equal (len (rev x))
                               (len x)))
  (if (endp x)
    nil
    (app (rev (rest x)) (list (first x)))))

(defunc sum (l)
  :input-contract (natlistp l)
  :output-contract (natp (sum l))
  (if (endp l)
      0
    (+ (first l) (sum (rest l)))))

Recall that for each of the defunc's above we have both a definitional axiom

(ic => (f <args>) = <function body>)

(you can refer to it in justifications as "def. f"), and a contract theorem

(ic => oc).

Definitional axioms and contract theorems of admitted functions are
available for you to use.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; For the following conjectures, follow all proof steps outlined above.

(a)

(implies (and (listp x)
              (listp y))
         (equal (len (app x y))
                (len (app y x))))

Hint: carefully observe (and use) the involved functions' contracts.

The claim is true. Here is the proof:

Context:
C1. (listp x)
C2. (listp y)

Proof:

  (len (app x y))
=  { app contract theorem }
  (len x) + (len y)
=  { arithmetic }
  (len y) + (len x)
=  { app contract theorem }
  (len (app y x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(b)

(implies (and (listp x)
              (listp y))
	 (equal (app (rev x) (rev y))
		(rev (app x y))))

The claim is false. Here is a counterexample:

x = (1 2) , y = (3) .

Then [[(listp x)]] = [[(listp y)]] = true, but
[[(app (rev x) (rev y))]] = [[(app (2 1) (3))]] = (2 1 3) , while
[[(rev (app x y))]] = [[(rev (1 2 3))]] = (3 2 1) .

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(c)

(implies (and (listp x)
	      (listp y))
	 (equal (len (app (rev x) (rev y)))
		(len (rev (app x y)))))

The claim is true. Here is the proof:

Context:

C1. (listp x)
C2. (listp y)

Proof:

  (len (app (rev x) (rev y)))

= { app contract theorem with subst. ((a (rev x)) (b (rev y))) }

  (+ (len (rev x)) (len (rev y)))

= { rev contract theorem }

  (+ (len x) (len y))

= { app contract theorem }

  (len (app x y))

= { rev contract theorem with subst. ((x (app x y)))  }

  (len (rev (app x y)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(d)

(implies (and (listp x)
              (listp y)
              (listp z))
	 (implies (equal (twice (app      x     z)) (app (twice      x    ) (twice z)))
		  (equal (twice (app (cons x y) z)) (app (twice (cons x y)) (twice y)))))

The claim is false. Here is a counterexample: ((x nil) (y nil) (z '(1)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(e)

(implies (listp x)
         (and (implies (endp x)
                       (equal (len (twice x))
                              (* 2 (len x))))
              (implies (and (not (endp x))
                            (equal (len (twice (rest x)))
                                   (* 2 (len (rest x)))))
                       (equal (len (twice x))
                              (* 2 (len x))))))

The claim is true. To prove it, we split the proof goal into two:

(1)

(implies (listp x)
	 (implies (endp x)
		  (equal (len (twice x))
			 (* 2 (len x)))))

which we rewrite into

(implies (and (listp x) (endp x))
	 (equal (len (twice x))
		(* 2 (len x))))

Context:

C1. (listp x)
C2. (endp x)
C3. x = nil { C1, C2 }

  (len (twice x))

= { def. axiom twice, C2, axioms if }

  (len nil)

= { def. axiom len, axioms atom, if }

  0

= { arithmetic }

  (* 2 0)

= { def. axiom len, axioms atom, if }

  (* 2 (len nil))

= { C3 }

  (* 2 (len x))


(2)

(implies (listp x)
	 (implies (and (not (endp x))
		       (equal (len (twice (rest x)))
			      (* 2 (len (rest x)))))
		  (equal (len (twice x))
			 (* 2 (len x)))))

which we rewrite into

(implies (and (listp x)
	      (not (endp x))
	      (equal (len (twice (rest x)))
		     (* 2 (len (rest x)))))
	 (equal (len (twice x))
		(* 2 (len x))))

Context:

C1. (listp x)
C2. (not (endp x))
C3. (equal (len (twice (rest x))) (* 2 (len (rest x))))

(len (twice x))

= { def. axiom twice, C2 }

(len (cons (first x) (cons (first x) (twice (rest x)))))

= { def. axiom len; axioms cons, atom, if }

(+ 1 (len (cons (first x) (twice (rest x)))))

= { def. axiom len; axioms cons, atom, if }

(+ 1 (+ 1 (len (twice (rest x)))))

= { arithmetic; C3 }

(+ 2 (* 2 (len (rest x))))

= { arithmetic }

(* 2 (+ 1 (len (rest x))))

= { def. axiomx len, C2, axioms if, atom }

(* 2 (len x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; The following conjectures are true; prove them following the instructions outlined above.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(f)

(implies (and (natlistp x) (natlistp l))
	 (and (implies (endp x)
		       (equal (sum (app x l)) (+ (sum x) (sum l))))
	      (implies (and (natp a)
			    (equal (sum (app x l)) (+ (sum x) (sum l))))
		       (equal (sum (app (cons a x) l)) (+ (sum (cons a x)) (sum l))))))

- conjecture contract checking: successful

- propositional reasoning: we split the proof obligation into two parts, as follows.

(1)

(implies (and (natlistp x) (natlistp l) (endp x))
	 (equal (sum (app x l)) (+ (sum x) (sum l))))

C1. natlistp x
C2. natlistp l
C3. endp x

  (sum (app x l))

= { def. axiom app, C3 }

  (sum l)

= { arithmetic }

  (+ 0 (sum l))

= { def. axiom sum, C3 }

  (+ (sum x) (sum l))

(2)

(implies (and (natlistp x)
	      (natlistp l)
	      (natp a)
	      (equal (sum (app x l)) (+ (sum x) (sum l))))
	 (equal (sum (app (cons a x) l)) (+ (sum (cons a x)) (sum l))))

C1. (natlistp x)
C2. (natlistp l)
C3. (natp a)
C4. (sum (app x l)) = (+ (sum x) (sum l))

  (sum (app (cons a x) l))

= { def. axiom app, endp; axioms cons, if }

  (sum (cons (first (cons a x)) (app (rest (cons a x)) l))

= { axioms cons, first, rest }

  (sum (cons a (app x l))

= { def. axiom sum, endp; axioms cons, if }

  (+ (first (cons a (app x l))) (sum (rest (cons a (app x l)))))

= { axioms cons, first, rest }

  (+ a (sum (app x l)))

= { C4 }

  (+ a (+ (sum x) (sum l)))

= { arithmetic }

  (+ (+ a (sum x)) (sum l))

= { axioms cons, first, rest }

  (+ (+ (first (cons a x)) (sum (rest (cons a x)))) (sum l))

= { def. axiom sum, endp; axioms cons, if }

  (+ (sum (cons a x)) (sum l)

|#
