#|

CS 2800 Homework 8 - Fall 2014

Student names: This homework is done in pairs. Put BOTH names here.

Technical instructions:

- open this file in ACL2s BEGINNER mode as hw08.lisp

- insert your solutions into this file where indicated (usually as "...")

- only add to the file. Do not remove or comment out anything pre-existing.

- make sure the entire file is accepted by ACL2s. In particular, there must
  be no "..." left in the code. If you don't finish some problems, comment
  them out. The same is true for any English text that you may add. This
  file already contains many comments, so you can see what the syntax is.

- when done, save your file and submit it as hw08.lisp.

- avoid submitting the session file (which shows your interaction with the
  theorem prover). This is not part of your solution.

Instructions for programming problems:

For each function definition, you must provide both contracts and a body.

You must also ALWAYS supply your own tests. This is in addition to the
tests sometimes provided. Make sure you produce sufficiently many new test
cases. This means: cover at least the possible scenarios according to the
data definitions of the involved types. For example, a function taking two
lists should have at least 4 tests: all combinations of each list being
empty and non-empty.

Beyond that, the number of tests should reflect the difficulty of the
function. For very simple ones, the above coverage of the data definition
cases may be sufficient. For complex functions with numerical output, you
want to test whether it produces the correct output on a reasonable
number if inputs.

Use good judgment. For unreasonably few test cases we will deduct points.

We will use ACL2s' check= facility for tests. This function is similar to
the equal function, except that if the evaluations of the two arguments
passed to it are not equal, the function call results in an error message
(rather than returning nil, as in the case of equal). Thus, if any call to
check= results in "not equal", your file will be rejected.

|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Equational reasoning
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|

Instructions for equational reasoning problems:

- perform conjecture contract checking, and add hypotheses if necessary

- run some tests to make an educated guess as to whether the conjecture is
  true or false. In the latter case, find a counterexample to the
  conjecture. In the former case, continues as below.

- use propositional reasoning to rewrite the conjecture into an implication
  with a conjunction of hypotheses in the antecedent and a single
  expression in the conclusion. If that is not possible, you may have to
  split the proof into several parts such that each part can be rewritten
  into such an implication.

- for each implication, extract the context (the hypotheses), and determine
  the derived context: anything that follows immediately from the context
  expressions and may be useful later.

- now perform the proof.

When writing your equational reasoning proofs be sure to justify each step
in the style shown in class, eg.

  (len ())
= { def len }
  0

You can use basic arithmetic facts for free, but in the justification write
"arithmetic", e.g.,

  (first x) + (len (rest x)) + (sum y) + 0
= { Arithmetic }
  (sum y) + (first x) + (len (rest x))

You may use infix notation like x+y+z for arithmetic operators (as done
above), instead of the LISP style prefix notation like (+ x (+ y z)).

You can of course also use previously (in class or in homework) proved
theorems. In this case, cite the theorem in the justification, and give the
substitution that shows how you instantiated the theorem.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Here are the definitions used for the remainder of the questions. (Note:
these may be different from earlier definitions of these functions -- what
counts are the definitions provided here.)

(defunc len (x)
  :input-contract (listp x)
  :output-contract (natp (len x))
  (if (endp x)
      0
    (+ 1 (len (rest x)))))

(defunc twice (l)
  :input-contract (listp l)
  :output-contract (listp (twice l))
  (if (endp l)
    nil
    (cons (first l) (cons (first l) (twice (rest l))))))

(defunc app (a b)
  :input-contract (and (listp a) (listp b))
  :output-contract (and (listp (app a b))
                        (equal (len (app a b))
                               (+ (len a) (len b))))
  (if (endp a)
    b
    (cons (first a) (app (rest a) b))))

(defunc rev (x)
  :input-contract (listp x)
  :output-contract (and (listp (rev x))
                        (equal (len (rev x))
                               (len x)))
  (if (endp x)
    nil
    (app (rev (rest x)) (list (first x)))))

(defunc in (x l)
  :input-contract (listp l)
  :output-contract (booleanp (in x l))
  (cond ((endp l)            nil)
        ((equal x (first l)) t)
        (t                   (in x (rest l)))))

(defunc sum (l)
  :input-contract (natlistp l)
  :output-contract (natp (sum l))
  (if (endp l)
      0
    (+ (first l) (sum (rest l)))))

(defunc fib (n)
  :input-contract (natp n)
  :output-contract (natp (fib n))
  (if (<= n 1)
    n
    (+ (fib (- n 1))
       (fib (- n 2)))))

(defunc evenp (n)
  :input-contract t
  :output-contract (booleanp (evenp n))
  (if (integerp n)
    (integerp (/ n 2))
    nil))

(defdata natlist (listof nat))

(defunc subsetp (l1 l2)
  :input-contract (and (listp l1) (listp l2))
  :output-contract (booleanp (subsetp l1 l2))
  (cond ((endp l1)          t)
        ((in (first l1) l2) (subsetp (rest l1) l2))
        (t                  nil)))

(defunc intersect (l1 l2)
  :input-contract (and (listp l1) (listp l2))
  :output-contract (listp (intersect l1 l2))
  (cond ((endp l1)          nil)
        ((in (first l1) l2) (cons (first l1) (intersect (rest l1) l2)))
        (t                  (intersect (rest l1) l2))))

(defunc ziplists (x y)
  :input-contract (and (listp x) (listp y) (equal (len x) (len y)))
  :output-contract (listp (ziplists x y))
  (if (endp x)
    nil
    (cons (list (first x) (first y))
          (ziplists (rest x) (rest y)))))

Recall that for each of the defunc's above we have both a definitional axiom

(ic => (f <args>) = <function body>)

(you can refer to it in justifications as "def. f"), and a contract theorem

(ic => oc)

(you can refer to it in justifications as "oc of f").

Definitional axioms and contract theorems of admitted functions are
available for you to use.

A "natlist" is a list of natural numbers. You can assume that a natlist is
a list, that reversing a natlist results in a natlist, and that consing a
nat onto a natlist results in a natlist.

|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|

1.

When proving the following conjecture, you can assume the following is a
theorem:

(Thm. 1)

(implies (and (natlistp l1) (natlistp l2))
	 (equal (sum (app l1 l2)) (+ (sum l1) (sum l2))))

If you make use of it, you must cite it ("Thm. 1"), and provide a
substitution that shows how you apply it.

Conjecture:

(implies (natlistp x)
	 (and (implies (endp x)
		       (equal (sum (rev x)) (sum x)))
	      (implies (and (natp a)
			    (equal (sum (rev x)) (sum x)))
		       (equal (sum (rev (cons a x))) (sum (cons a x))))))


- conjecture contract checking: successful

- propositional reasoning: we split the proof obligation into two parts, as follows.

(1)

(implies (and (natlistp x) (endp x))
	 (equal (sum (rev x)) (sum x)))

C1. (natlistp x)
C2. (endp x)
C3. x = nil { C1,C2 }

  (sum (rev x))

= { C2 }

  (sum nil)

= { C3 }

  (sum x)

(2)

(implies (and (natlistp x)
	      (natp a)
	      (equal (sum (rev x)) (sum x)))
	 (equal (sum (rev (cons a x))) (sum (cons a x))))

C1. (natlistp x)
C2. (natp a)
C3. (equal (sum (rev x)) (sum x))

  (sum (rev (cons a x)))

= { def. axiom rev }

  (sum (app (rev (rest (cons a x))) (list (first (cons a x)))))

= { axioms cons, first, rest }

  (sum (app (rev x) (list a)))

= { instantiating theorem above, with substitution ((l1 (rev x)) (l2 (list a))) }

  (+ (sum (rev x)) (sum (list a)))

= { C3; def. axiom sum, endp; axioms cons, if }

  (+ (sum x) (+ (first (list a)) (sum (rest (list a)))))

= { axioms first, rest }

  (+ (sum x) (+ a (sum nil))

= { def. axiom sum; arithmetic }

  (+ (sum x) a)

= { arithmetic; axioms cons, first, rest }

  (+ (first (cons a x)) (sum (rest (cons a x))))

= { def. axiom sum }

  (sum (cons a x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

2.

Consider the following conjecture:

(and (implies (equal n 1)
	      (implies (evenp (fib n))
		       (and (not (evenp (fib (- n 1))))
			    (not (evenp (fib (+ n 1)))))))
     (implies (and (natp n)
		   (>= n 2)
		   (implies (evenp (fib n))
			    (and (not (evenp (fib (- n 1))))
				 (not (evenp (fib (+ n 1)))))))
	      (implies (evenp (fib (+ n 1)))
		       (and (not (evenp (fib    n  )))
			    (not (evenp (fib (+ n 2))))))))

(Note: this conjecture is used in proving, by induction, that whenever
fib(n) is even, both fib(n-1) and fib(n+1) are odd. That is, the Fibonacci
sequence defined by the fib function does not contain two consecutive even
numbers.)

Prove this conjecture using equational reasoning.

Hint: the proof has four parts!

We split the proof into four parts.

(1) After conjecture contract checking:

(implies (and (natp n) (equal n 1))
	 (implies (evenp (fib n))
		  (not (evenp (fib (- n 1))))))

Context:

C1. (natp n)
C2. (equal n 1)
C3. (evenp (fib n))

Derived context:

C4. (evenp (fib 1)) { C2, C3 }
C5. nil             { C4, def. axioms fib, evenp, arithmetic }

(End of proof.)

(2) The proof of

(implies (and (natp n) (equal n 1))
	 (implies (evenp (fib n))
		  (not (evenp (fib (+ n 1))))))

is analogous.

(3) After conjecture contract checking:

(implies (and (natp n)
	      (>= n 2)
	      (implies (evenp (fib n))
		       (and (not (evenp (fib (- n 1))))
			    (not (evenp (fib (+ n 1)))))))
	 (implies (evenp (fib (+ n 1)))
		  (not (evenp (fib n)))))


Context:

C1. (natp n)
C2. (>= n 2)
C3. (evenp (fib n)) => (not (evenp (fib (- n 1)))) /\ (not (evenp (fib (+ n 1))))
C4. (evenp (fib (+ n 1)))

Derived context:

C5. (evenp (fib (- n 1))) \/ (evenp (fib (+ n 1))) => (not (evenp (fib n))) { C3, propositional reasoning }
C6. (evenp (fib (- n 1))) \/ (evenp (fib (+ n 1)))                          { C4, propositional reasoning }
C7. (not (evenp (fib n)))                                                   { C6, C5, MP }

Proof:

  (not (evenp (fib n))) { C7 }

(4) After conjecture contract checking:

(implies (and (natp n)
	      (>= n 2)
	      (implies (evenp (fib n))
		       (and (not (evenp (fib (- n 1))))
			    (not (evenp (fib (+ n 1)))))))
	 (implies (evenp (fib (+ n 1)))
		  (not (evenp (fib (+ n 2))))))

Context:

C1. (natp n)
C2. (>= n 2)
C3. (evenp (fib n)) => (not (evenp (fib (- n 1)))) /\ (not (evenp (fib (+ n 1))))
C4. (evenp (fib (+ n 1)))

Derived context:

C5. (evenp (fib (- n 1))) \/ (evenp (fib (+ n 1))) => (not (evenp (fib n))) { C3, propositional reasoning }
C6. (evenp (fib (- n 1))) \/ (evenp (fib (+ n 1)))                          { C4, propositional reasoning }
C7. (not (evenp (fib n)))                                                   { C6, C5, MP }

Proof:

  (not (evenp (fib (+ n 2))))

= { def. axiom fib, C2, arithmetic }

  (not (evenp (+ (fib (+ n 1)) (fib n))))

= { C4, C7, arithmetic: even + odd = odd }

  (not nil)

= { propositional reasoning }

  t

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

3.

Prove the following using equational reasoning:

(implies (and (listp x) (listp y) (equal (len x) (len y)))
         (and (implies (endp x)
                       (equal (len (ziplists x y))
                              (len x)))
              (implies (and (consp x)
                            (equal (len (ziplists (rest x) (rest y)))
                                   (len (rest x))))
                       (equal (len (ziplists x y))
                              (len x)))))

- conjecture contract checking: successful

- propositional reasoning: we split the proof into two parts.

(a)

(implies (and (listp x) (listp y) (equal (len x) (len y)))
         (implies (endp x) 
		  (equal (len (ziplists x y))
			 (len x))))

which can be rewritten to

(implies (and (listp x) (listp y) (equal (len x) (len y)) (endp x))
	 (equal (len (ziplists x y)) (len x)))

C1. (listp x)
C2. (listp y)
C3. (equal (len x) (len y))
C4. (endp x))
C5. x = nil { C1,C4 }
C6. y = nil { C5,C3 }

  (len (ziplists x y))

= { def. ziplists, C5 }

  (len nil)

= { def. len }

  0

= { C5, def. len }

  (len x)

(b)

(implies (and (listp x) (listp y) (equal (len x) (len y)))
	 (implies (and (consp x)
		       (equal (len (ziplists (rest x) (rest y)))
			      (len (rest x))))
		  (equal (len (ziplists x y))
			 (len x))))

which can be rewritten to

(implies (and (listp x) (listp y) (equal (len x) (len y))
	      (consp x) (equal (len (ziplists (rest x) (rest y)))
			       (len (rest x))))
	 (equal (len (ziplists x y))
		(len x)))

C1. (listp x)
C2. (listp y)
C3. (equal (len x) (len y))
C4. (consp x)
C5. (len (ziplists (rest x) (rest y))) = (len (rest x))

  (len (ziplists x y))

= { def. ziplists, C4 }

  (len (cons (list (first x) (first y))
	     (ziplists (rest x) (rest y))))

= { thm: (len (cons a l)) = 1 + (len l), subst ((a (list (first x) (first y))) (b (ziplists (rest x) (rest y)))) }

  1 + (len (ziplists (rest x) (rest y)))

= { C5 }

  1 + (len (rest x))

= { def len, atom; C4 }

  (len x)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

4.

Consider the following conjecture.

(implies
  (and (consp l1)
       (in (first l1) l2)
       (implies (subsetp (rest l1) l2)
                (equal (intersect (rest l1) l2) (rest l1))))
  (implies (subsetp l1 l2)
           (equal (intersect l1 l2) l1)))

Convince yourself that the conjecture satisfies the input contracts of all
functions occurring in it.

(a) Use propositional reasoning to simplify the conjecture into an
implication with a conjunction of hypotheses as antecedent, and an
``atomic'' consequent (i.e., one that contains no Boolean operators inside
it).

(implies
  (and (consp l1)
       (in (first l1) l2)
       (implies (subsetp (rest l1) l2)
                (equal (intersect (rest l1) l2) (rest l1)))
       (subsetp l1 l2))
  (equal (intersect l1 l2) l1))

(b) Extract the context from the conjecture.

C1. (consp l1)
C2. (in (first l1) l2)
C3. (subsetp (rest l1) l2) => (intersect (rest l1) l2) = (rest l1)
C4. (subset l1 l2)

(c) Derive additional context that may be useful in proving the conjecture.
Remember to justify each such derived context.

C5. (subset (rest l1) l2)                { def. subset, C4,C1,C2 }
C6. (intersect (rest l1) l2) = (rest l1) { C3,C5,MP }


(d) Prove the conjecture using equational reasoning. Be sure to justify
each step.

  (intersect l1 l2)

= { def. intersect, C1, C2 }

  (cons (first l1) (intersect (rest l1) l2))

= { C6 }

  (cons (first l1) (rest l1))

= { axioms first, rest, cons }

  l1

|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Fibonacci -- Made Efficient
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; We reduce the amount of testing done by ACL2 while it admits a function:
(acl2::acl2s-defaults :set acl2::subgoal-timeout 1)

;; Now recall the definition of the fib function from above. We also define
;; the type natlist, for later use.

(defunc fib (n)
  :input-contract (natp n)
  :output-contract (natp (fib n))
  (if (<= n 1)
    n
    (+ (fib (- n 1))
       (fib (- n 2)))))

(defdata natlist (listof nat))

#|

This is an elegant and very easy to read definition. But it is also very
slow. To see why, we trace the recursive calls to fib when processing
input. This is done as follows:

|#

(acl2::trace! fib)
(acl2::set-guard-checking :none)

#|

(Hint: you can use (acl2::untrace$ fib) to stop tracing the function.)

Now try fib using some _small_ inputs. Start with n=1, n=2, to get a
feeling for the output trace produces. A line of the form
 > (FIB 1)

indicates that fib was called recursively with argument 1, whereas

 < (FIB 1)

indicates that a recursive call to fib with argument 1 was completed.

In the evaluation of (fib  5), how many times is fib called on argument 1 ? 5
In the evaluation of (fib 10), how many times is fib called on argument 1 ? 55

Hint: you can use the Eclipse editor to count occurrences of certain text
strings, or you can copy the output of trace into your favorite alternative
editor.

Compare the above numbers with the values (fib 5) and (fib 10). What do you
find? when evaluating (fib n), (fib 1) is called (fib n) times

You saw how long the trace output of (fib 10) is -- for a fairly small
input of 10. Let's see whether we can make fib more efficient. Our fib-fast
function will be hard for ACL2 to prove terminating, so we write this
function in program mode:

|#

:program

#|

The idea is as follows. First write a function fib-help that, for input n,
computes the _list_ of Fibonacci numbers 0,1,1,2,3,5,8,... in _descending_
order from (fib n) down to (fib 0) = 0. See tests below, and also note the
output contract, which is provided for you. Provide 3 more tests.

To minimize the number of recursive calls required to evaluate (fib-help n),
you MUST use (let ...)  whenever you need the result of a recursive call
several times. Your solution will be considered incorrect if your code contains
several calls to fib-help with the same arguments.

|#

(defunc fib-help (n)
  :input-contract (natp n)
  :output-contract (and (natlistp (fib-help n)) (equal (len (fib-help n)) (+ n 1)))
  (cond ((equal n 0) '(0))
        ((equal n 1) '(1 0))
        (t
         (let ((r (fib-help (- n 1))))
           (cons (+ (first r) (second r)) r)))))

(check= (fib-help 0) '(0))
(check= (fib-help 1) '(1 0))
(check= (fib-help 3) '(2 1 1 0))

;; Now write a non-recursive function fib-fast, with contracts as for the
;; (slow) fib function, which calls fib-help to compute (fib n).

(defunc fib-fast (n)
  :input-contract (natp n)
  :output-contract (natp (fib-fast n))
  (first (fib-help n)))

;; Now let's see whether fib-fast deserves that name. Turn on tracing for
;; the helper function (fib-fast itself is not recursive):

(acl2::trace! fib-help)

#|

In the evaluation of (fib-fast  5), how many times is fib-help called on argument 1 ? 1
In the evaluation of (fib-fast 10), how many times is fib-help called on argument 1 ? 1

Compare your results to those obtained with (fib n).

You can also try fib and fib-fast on input 100. Hint: try fib-fast first!

|#
