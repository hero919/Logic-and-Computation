#|

CS 2800 Homework 6 - Fall 2014

Student names: This homework is done in pairs. Put BOTH names here.

Technical instructions:

- open this file in ACL2s BEGINNER mode as hw06.lisp

- insert your solutions into this file where indicated (usually as "...")

- only add to the file. Do not remove or comment out anything pre-existing.

- make sure the entire file is accepted by ACL2s. In particular, there must
  be no "..." left in the code. If you don't finish some problems, comment
  them out. The same is true for any English text that you may add. This
  file already contains many comments, so you can see what the syntax is.

- when done, save your file and submit it as hw06.lisp.

- avoid submitting the session file (which shows your interaction with the
  theorem prover). This is not part of your solution.

Instructions for programming problems:

For each function definition, you must provide both contracts and a body.

You must also ALWAYS supply your own tests. This is in addition to the
tests sometimes provided. Make sure you produce sufficiently many new test
cases. This means: cover at least the possible scenarios according to the
data definitions of the involved types. For example, a function taking two
lists should have at least 4 tests: all combinations of each list being
empty and non-empty.

Beyond that, the number of tests should reflect the difficulty of the
function. For very simple ones, the above coverage of the data definition
cases may be sufficient. For complex functions with numerical output, you
want to test whether it produces the correct output on a reasonable
number if inputs.

Use good judgment. For unreasonably few test cases we will deduct points.

We will use ACL2s' check= facility for tests. This function is similar to
the equal function, except that if the evaluations of the two arguments
passed to it are not equal, the function call results in an error message
(rather than returning nil, as in the case of equal). Thus, if any call to
check= results in "not equal", your file will be rejected.

|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Terminates?
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|

For the following problems, determine whether the given function f
terminates. If it does, provide a measure function m such that

1. m has the same arguments and the same input contract as f.
2. m's output contract is (natp (m ...))
3. m is admissible.

Unless clearly stated otherwise, you also need to prove that

4. on every recursive call of f, given <ic> and under the conditions that
   lead to that call, m applied to the arguments in the call is less than m
   applied to the original inputs.

You should do this proof as shown in class (which is also the way we will
expect you to prove termination in exams):

- write down the propositional logic formalization of the above condition 4
- simplify the formula
- conclude the formula is valid.

Unless clearly stated otherwise, you need to follow these steps for EACH
recursive call separately.

If you determine f does not terminate, provide an input on which the
function runs forever.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

1.

(defunc z (l1 l2)
  :input-contract (and (listp l1) (listp l2))
  :output-contract (listp (z l1 l2))
  (cond ((endp l1)             ())
        ((< (len l1) (len l2)) (z (cons 1 l1) (rest l2)))
        (t                     (z (rest l1) (cons 2 l2)))))

This function does not terminate.
A non-terminating run is (z '(1 1) '(1 1)).

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

2.

(defunc h (a b)
  :input-contract (and (integerp a) (natp b))
  :output-contract (natp (h a b))
  (cond ((> b a)     b)
        ((equal b 0) (h (- a 1) b))
        (t           (h a (+ b 1)))))

This function terminates; a measure function is:

(defunc m (a b)
  :input-contract (and (integerp a) (natp b))
  :output-contract (natp (m a b))
  (if (< a b)
    0
    (+ (- a b) 1)))

Case ~(b > a) /\ b=0, i.e. 0 = b <= a:
      (i)  Suppose b  = a. Then m(a-1,b) = 0 < m(a,b) = 1.
      (ii) Suppose b ~= a, i.e. b < a.
           Then m(a-1,b) = (a-1)-b+1 = a-b < m(a,b) = a-b+1.

Case ~(b > a) /\ ~(b=0), i.e. b <= a /\ b ~= 0:
      (i)  Suppose b  = a. Then m(a,b+1) = 0 < m(a,b) = 1.
      (ii) Suppose b ~= a, i.e. b < a.
           Then m(a,b+1) = a-(b+1)+1 = a-b < m(a,b) = a-b+1.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

3.

(defunc g (n)
  :input-contract (natp n)
  :output-contract t
  (cond ((equal n 0) 0)
        ((> n 3)     (+ 1 (g (- n 1))))
        (t           (- 3 (g (* 2 n))))))

doesn't terminate: (g 1) goes into an infinite loop: n=1,2,4,3,6,5,4, ...

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

4.

(defunc h (l p)
  :input-contract (and (listp l) (consp p))
  :output-contract (booleanp (h l p))
  (cond ((> (len p) (len l)) t)
        ((endp (rest p))     (h (rest l) p))
        (t                   (h l (cons nil p)))))

terminates; a measure is

(defunc m (l p)
  :input-contract (and (listp l) (consp p))
  :output-contract (natp (m l p))
  (if (< (len l) (len p))
      0
      (+ (- (len l) (len p)) 1)))

  Both recursive calls happen only if |p| <= |l|.
  Hence (m l p) = |l| - |p| + 1.

  First recursive call:

  If |(rest l)| <  |p|, then (m (rest l) p) = 0 < 1 <= |l| - |p| + 1 = (m l p)
  If |(rest l)| >= |p|, then (m (rest l) p) = |(rest l)| - |p| + 1 < |l| - |p| + 1 = (m l p)

  Second recursive call:

  If |l|  < |(cons nil p)|, then (m l (cons nil p)) = 0 < |l| - |p| + 1 = (m l p)
  If |l| >= |(cons nil p)|, then (m l (cons nil p)) = |l| - |(cons nil p)| + 1 = |l| - |p| < |l| - |p| + 1 = (m l p)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

5.

(defunc f (x y)
  :input-contract (and (listp x) (integerp y))
  :output-contract (natp (f x y))
  (cond ((and (endp x) (equal y 0)) 0)
        ((and (endp x) (< y 0))     (+ 1 (f x (+ 1 y))))
        ((endp x)                   (+ 1 (f x (- y 1))))
        (t                          (+ 1 (f (rest x) y)))))

If terminating, prove condition 4 only for the *second* recursive call
(guarded by (endp x) ).

yes: measure is

(defunc m (x y)
  :input-contract (and (listp x) (integerp y))
  :output-contract (natp (m x y))
  (+ (len x) (abs y)))

Condition 4 for the *second* recursive call (guarded by (endp x)):

(listp x) ^ (integerp y) ^ ~((endp x) ^ y=0) ^ ~((endp x) ^ y<0) ^ (endp x) => (m x y-1) < (m x y)
ic ^ y != 0 ^ y >= 0 ^ (endp x) => (m x y-1) < (m x y)
ic ^ y > 0 ^ (endp x) => len(x) + |y-1| < len(x) + |y|
ic ^ y > 0 ^ (endp x) => |y-1| < |y|
ic ^ y > 0 ^ (endp x) => y-1 < y

valid

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

6.

(defunc f (x a)
  :input-contract (and (integerp  x) (listp a))
  :output-contract (natp (f x a))
  (cond ((< x 0)   (f (len a) (app a a)))
        ((endp a)  0)
        (t         (+ 1 (f x (rest a))))))

yes, measure is

(defunc m (x a)
  :input-contract (and (integerp  x) (listp a))
  :output-contract (natp (m x y))
  (if (< x 0)
      (+ (* 2 (len a)) 1)
      (len a)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Terminates!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|

The following functions terminate. Provide a measure function m
and prove the conditions outlined above in section "Terminates?".

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

7.

(defunc f (x y z)
  :input-contract (and (natp x) (natp y) (listp z))
  :output-contract (natp (f x y z))
  (cond ((equal x 0) (+ y (len z)))
        ((endp z)    (+ x y))
        ((<= y 1)    (+ x (f (- x 1) 0 (rest z))))
        ((< x y)     (f x (- y 2) z))
        (t           (f x y (rest z)))))

Prove condition 4 only for the *first* recursive call (guarded by (<= y 1) ).

A measure function is:

  (defunc m (x y z)
    :input-contract (and (natp x) (natp y) (listp z))
    :output-contract (natp (m x y z))
    (+ x (+ y (len z))))

  Here is what we need to show for the _first_ recursive call:

~(equal x 0) /\ ~(endp z) /\ (<= y 1) => (m (- x 1) 0 (rest z)) < (m x y z)

~(equal x 0) /\ ~(endp z) /\ (<= y 1) => (- x 1) + 0 + (len (rest z)) < x + y + (len z)

  both of which are true by arithmetic, and by (len (rest z)) < (len z).

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

8.

(defunc h (a b c)
  :input-contract (and (natp a) (integerp b) (listp c))
  :output-contract (natp (h a b c))
  (cond ((equal a 0) (len c))
        ((endp c)    (+ a b))
        ((<= b 1)    (+ a (h (- a 1) (+ b 1) (rest c))))
        ((< a b)     (h a (- b 2) c))
        (t           (h a b (rest c)))))

Prove condition 4 only for the *first* recursive call (guarded by (<= b 1) ).

A measure function is:

(defunc m (a b c)
  :input-contract (and (natp a) (integerp b) (listp c))
  :output-contract (natp (m a b c))
  (+ a (+ (abs b) (len c))))

  We need to prove:

(natp a) /\ (integerp b) /\ (listp c) /\ ~(equal a 0) /\ ~(endp c) /\ (<= b 1)
=>
(m a-1 b+1 (rest c)) < (m a b c)

Here is a formal equational reasoning proof:

C1. (natp a)
C2. (integerp b)
C3. (listp c)
C4. a != 0
C5. (consp c)
C6. b <= 1

  (m a-1 b+1 (rest c))

= { def. m }

  a-1 + abs(b+1) + (len (rest c))

<= { arithmetic; def. len }

  a-1 + abs(b)+1 + (len c)-1

< { cancelation; arithmetic }

  a + abs(b) + (len c)

= { def. m }

  (m a b c)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

9.

(defunc f (a b)
  :input-contract  (and (natp a) (natp b))
  :output-contract (natp (f a b))
  (cond
    ((and (equal a 0) (equal b 0))  0)
    ((< a b)                        (f b a))
    (t                              (f b (- a 1)))))

Measure is

(defunc m (a b)
  :input-contract  (and (natp a) (natp b))
  :output-contract (natp (m a b))
  (cond ((> a (+ 1 b))  (- (* 2 a) 1))
        ((> b a)        (* 2 b))
        (t              (+ a b))))

The proof of the measure function properties is left as an exercise.

|#



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Termination arguments
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|

10. Albert is considering the following function:

    (defunc wicked (a b c)
      :input-contract (and (integerp a) (posp b) (integerp c))
      :output-contract (integerp (wicked a b c))
      (cond ((>= a b) a)
            ((>= b c) b)
            ((< c 0)  (wicked (+ a b) b c))
            (t        (wicked a b (+ a b)))))

(a) Albert claims that this function will be admitted by ACL2s since its
body is a legal expression satisfying all body contracts, and the output
contract is trivially satisfied as well. But he forgot something! Show that
the function does not (always) terminate, by giving an input in the form of
concrete values a,b,c that satisfies the input contract but causes an
infinite execution.

(a,b,c)=(1,2,3). It turns out that this function *never*
terminates if the input causes a recursive call.

(b) Albert admits there were several typos in his definition. His new
proposal is (read carefully!):

(defunc wicked (a b c)
  :input-contract (and (posp a) (posp b) (integerp c))
  :output-contract (integerp (wicked a b c))
  (cond ((>= a b) a)
        ((< c 0)  (wicked (+ a b) b c))
        (t        (wicked a b (- a b)))))

Prove that this function terminates.

Hint: First run function wicked on a few well-chosen test cases (exercising
all clauses of the cond) and see what happens. How long can chains of
recursive calls to this function actually be?

(defunc m (a b c)
  :input-contract (and (posp a) (posp b) (integerp c))
  :output-contract (natp (m a b c))
  (cond ((>= a b) 0)
        ((< c 0)  1)
        (t        2)))

Be sure that m would be admitted by ACL2s. Then prove that, on every
recursive call of wicked, the value of m decreases, under the conditions of
that recursive call.

c < 0 : m(a+b,b,c) = 0 < 1 = m(a,b,c) since a<b, c<0
t     : m(a,b,a-b) = 1 < 2 = m(a,b,c) since a<b, c>=0

|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|

11. Consider the following function definition:

(defunc count (i j c)
  :input-contract (and (natp i) (natp j) (natp c))
  :output-contract (natp (count i j c))
  (cond ((and (equal i 0) (equal j 0)) c)
        ((> j 0) (count i (- j 1) (+ c 1)))
        (t       (count (- i 1) 9 (+ c 1)))))

(a) Consider the call (count 2 3 0). Below are the first three argument
tuples that appear in recursive calls to count. Show the next three:

(2 3 0)  (2 2 1)  (2 1 2)  (2 0 3)  (1 9 4)  (1 8 5)

What does (count 2 3 0) evaluate to? 23

(b) Using the insights generated in (a), show that function count
terminates, by defining a measure function, and proving condition 4 as
outlined above.

(defunc m (i j c)
  :input-contract (and (natp i) (natp j) (natp c))
  :output-contract (natp (m i j c))
  (+ (* 10 i) j))

Proof that the value of m decreases on recursive calls.

j > 0 : m(i,j-1,c+1) = 10i+j-1 < 10i+j = m(i,j,c)
t     : m(i-1,9,c+1) = 10(i-1)+9 = 10i-1 < 10i+j = m(i,j,c)
        since j=0

|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|

12.

Given a (not necessarily admissible) ACL2s function f:X->Y and an element x
of X, let args_f(x) denote the set of elements of the ACL2s universe that f
is called upon during the evaluation of f(x) (including x itself). For
example, if f is len and x is (1 2), then args_f(x) = {(1 2),(2),()}.

(a) Consider

(defunc f (x)
  :input-contract (natp x)
  :output-contract (natp (f x))
  (cond ((<= x 1) 0)
        ((evenp x) (f (/ x 2)))
        (t         (f (- x 1)))))

Function evenp returns T whenever its integer argument is even.

Does this function terminate?

A possible measure function is m(x) = x.

(b) For the same function as in (a), determine the set args_f(5). How many
elements does this set have?

args_f(5) = {5,4,2,1}, which has 4 elements.

(c) Consider

(defunc f (x)
  :input-contract (natp x)
  :output-contract (natp (f x))
  (if (<= x 1)
    0
    (f (+ x 1))))

Does this function terminate?

x = 2: the function is called on ever increasing arguments.

(d) For the same function as in (c), determine the set args_f(5). How many
elements does this set have?

args_f(5) = {5,6,7,8,...}, which has infinitely many elements.

(e) Give an example of a function f and an input x such that

1. x satisfies f's input contract
2. f does not terminate on input x
3. args_f(x) is *finite*.

Clearly define your (inadmissible) function f, specify input x, explain why
f does not terminate on input x, and write down all elements of args_f(x).

(defunc f (x)
  :input-contract (booleanp x)
  :output-contract (booleanp (f x))
  (f (not x)))

Function f does not terminate on input x=T: it flip-flops. We have
args_f(x) = {T,nil}, which is finite.

|#


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; A TERMINATION TESTER
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|

The subject of this exercise is to study the problem of designing a
function that automatically checks whether another (recursively defined)
function terminates.

But wait -- we already know this problem is undecidable! That means there
is no ACL2s function that always determines correctly whether some given
other function f terminates.

We will therefore only solve a simple version of this problem: our function
will determine whether a given function f terminates in a predetermined
number of "steps". We will see shortly what "steps" means.

We begin with an example.

1. Define a function f that takes a positive natural number and is defined
mathematically as follows:

         1        if n is 1
       /
f(n) = - f(n/2)   if n is even
       \
         f(3*n+1) if n is greater than 1 and odd.

Here is how to read that notation: first observe that the three cases on
the right are mutually exclusive, i.e. every positive natural number fits
into exactly one case. Given n, determine which case it fits in. The
expression associated with that case determines f(n).

Define this function in ACL2s, in :program mode. Recall that (posp n)
recognizes positive natural numbers.

|#

:program

(defunc f (n)
  :input-contract (posp n)
  :output-contract (posp (f n))
  (cond ((equal n 1)        1)
        ((integerp (/ n 2)) (f (/ n 2)))
        (t                  (f (+ (* 3 n) 1)))))

; What does this function return, if anything?

;  it seems it always returns 1 

; Write at least 3 check= tests that (should) confirm your conjecture.

(check= (f  8)  1 )
(check= (f  5)  1 )
(check= (f 40)  1 )

#|

You can think of this function as generating a sequence of positive natural
numbers, namely the numbers that f is called on recursively. For example:

f(8) = f(4) = f(2) = f(1) = 1

To get a feel for f, write down the call sequences for the following
initial arguments, until the recursion ends:

f(10) = f(...) = ...
f( 7) = f(...) = ...

f(10) = f(5) = f(16) = f(8) = f(4) = f(2) = f(1) = 1
f(7) = f(22) = f(11) = f(34) = f(17) = f(52) = f(26) = f(13) = f(40) = f(20) = f(10) = f(5) = f(16) = f(8) = f(4) = f(2) = f(1) = 1

Hint: try out (acl2::trace! f)

The reason we have defined this function in :program mode is that ACL2s
cannot prove its termination. In fact, nobody knows whether this function
always terminates! You can read the whole story on Wikipedia. Search for
Collatz Conjecture.

Think about why it is (apparently) difficult to define a measure function
for f. Try it! (No response is required in your homework file.)

2. Modify f into a function f-c that takes not only n but also two other
arguments, count and limit, which are natural numbers such that count <=
limit. The idea is that count counts the number of recursive calls we have
to make to evaluate (f n). If that number exceeds limit, we abort the
entire computation and return the symbol ! (exclamation mark). Otherwise we
proceed as in f. The argument limit is a constant -- it is not changed in
recursive calls. Think about what values to pass to count in recursive
calls.

f-c : Pos x Nat x Nat -> Pos union {!}

The input contract MUST enforce the arithmetic relationship between count
and limit mentioned above. The output contract MUST state that f-c returns
a positive natural number OR the symbol ! .

|#

(defunc f-c (n count limit)
  :input-contract (and (posp n) (natp count) (natp limit) (<= count limit))
  :output-contract (or (posp (f-c n count limit)) (equal (f-c n count limit) '!))
  (cond ((equal count limit) '!)
        ((equal n 1)         1)
        ((integerp (/ n 2))  (f-c (/ n 2)       (+ count 1) limit))
        (t                   (f-c (+ (* 3 n) 1) (+ count 1) limit))))

(check= (f-c 8 0 2) '!)
(check= (f-c 8 0 3) '!)
(check= (f-c 8 0 4)  1)

; Write at least 3 more tests.

(check= (f-c 9 0 21)  1)
(check= (f-c 10 0 5) '!)
(check= (f-c 32 0 5) '!)

#|

3. Define a function f-terminates that takes two arguments: a positive
natural n and a natural number limit, and checks whether (f n) returns
after at most limit recursive calls. f-terminates returns a Boolean.
Obviously, in the body of f-terminates use f-c instead of f .

f-terminates : Pos x Nat -> Bool

|#

(defunc f-terminates (n limit)
  :input-contract (and (posp n) (natp limit))
  :output-contract (booleanp (f-terminates n limit))
  (posp (f-c n 0 limit)))

(check= (f-terminates 8 2) nil)
(check= (f-terminates 8 3) nil)
(check= (f-terminates 8 4) t)

; Write at least 3 more check= tests

(check= (f-terminates 9 21) t)
(check= (f-terminates 10 5) nil)
(check= (f-terminates 32 5) nil)

#|

4. Find the number *limit* of recursive calls that it takes for f to
terminate on input

1267650600228229401496703205376

That is, the following two tests must pass with your number *limit*,
which you should enter in place of the ... below:

|#

(defconst *limit* 101)

(check= (f-terminates 1267650600228229401496703205376 (- *limit* 1)) nil)
(check= (f-terminates 1267650600228229401496703205376    *limit*   ) t  )

#|

Hint: to determine *limit*, consider the trace mechanism mentioned above,
or binary search for the optimal parameters to f-c.

What is the mathematical relationship between the (large) input to f shown
above, and the number *limit* you found? Answer and explain in English.

*limit* is the log_2 of the input, plus 1.

5. Remember that f may not terminate on all inputs: nobody has been able to
prove that it does. Now observe that function f-terminates itself always
does terminate, even if f does not! The reason is that, instead of f, we
are using f-c within f-terminates, and f-c only recurs a given number of
times.

We can therefore use ...-terminates to test termination of functions even if
we _know_ they do not terminate. Consider:

|#

(acl2::acl2s-defaults :set acl2::testing-enabled nil) ; this turns off contract testing

(defunc g (n)
  :input-contract (integerp n)
  :output-contract (integerp (g n))
  (if (equal n 0)
    0
    (+ 1 (g (- n 1)))))

#|

This function behaves like the identity function on natural number inputs,
and diverges on all others. Try (g 10), (g 0), (g -1). What does ACL2s
return on the final example?

Now modify g into a function g-c that relates to g like f-c does to f. That
is, g-c counts the number of recursive calls we have to make to evaluate (g
n). If that number exceeds a given limit, we abort the entire computation and
return the symbol ! (exclamation mark).

g-c : Int x Nat x Nat -> Int union {!}

This function is a bit more tricky than f, as it is not tail-recursive!
'let' is your friend.

|#

(defunc g-c (n count limit)
  :input-contract (and (integerp n) (natp count) (natp limit) (<= count limit))
  :output-contract (or (integerp (g-c n count limit)) (equal (g-c n count limit) '!))
  (cond ((equal count limit) '!)
        ((equal n 0)         0)
        (t
         (let ((result (g-c (- n 1) (+ count 1) limit)))
           (if (equal result '!)
             '!
             (+ 1 result))))))

#|

Now define a similar wrapper function g-terminates that tests termination
of g within a pre-specified number of recursive calls. In the body of
g-terminates use g-c instead of g .

g-terminates : Int x Nat -> Bool

|#

(defunc g-terminates (n limit)
  :input-contract (and (integerp n) (natp limit))
  :output-contract (booleanp (g-terminates n limit))
  (integerp (g-c n 0 limit)))

(check= (g-terminates 10 10)  nil)
(check= (g-terminates 10 11)  t)
(check= (g-terminates -1 10)  nil) ; g does not terminate at all on this input
(check= (g-terminates -1 100) nil) ; g does not terminate at all on this input

; Write 2 more check= tests


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|

Some final comments (no response required): In this exercise, for every
function f we wanted to termination-test, we had to write a new function
f-terminates. Wouldn't it be better to have a function terminatesp that
takes (the code of) another function as input and performs the steps above?
so we don't have to write another function ?-terminates every time, which
anyway differs from the others mostly in the name of the function that is
being tested?

Yes, that would be better. But there are a number of difficulties. An
obvious one is that the different functions we want to test may take
different numbers of arguments, and may return different types of values.
So how many arguments would terminatesp have? and what would be their
types? Not obvious.

Supporting such "generic" terminatesp functions requires quite heavy
programming language support, such as higher-order functions: functions
that take other functions as input and can run them on arbitrary arguments.
As we have often mentioned, ACL2s does not support higher-order functions,
since they make proving theorems much much harder.

Note that a true termination prover would have to be a higher-order
procedure, since it takes another procedure/function as input.

|#
