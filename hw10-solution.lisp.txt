#|

CS 2800 Homework 10 - Fall 2014

Student names: This homework is done in pairs. Put BOTH names here.

Technical instructions:

- open this file in ACL2s BEGINNER mode as hw10.lisp

- insert your solutions into this file where indicated (usually as "...")

- only add to the file. Do not remove or comment out anything pre-existing.

- make sure the entire file is accepted by ACL2s. In particular, there must
  be no "..." left in the code. If you don't finish some problems, comment
  them out. The same is true for any English text that you may add. This
  file already contains many comments, so you can see what the syntax is.

- when done, save your file and submit it as hw10.lisp.

- avoid submitting the session file (which shows your interaction with the
  theorem prover). This is not part of your solution.

|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Induction Proofs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|

1. Consider the following function (you proved it terminating in HW06):

(defunc count (i j c)
  :input-contract (and (natp i) (natp j) (natp c))
  :output-contract (natp (count i j c))
  (cond ((and (equal i 0) (equal j 0)) c)
        ((> j 0)                       (count i (- j 1) (+ c 1)))
        (t                             (count (- i 1) 9 (+ c 1)))))

You can assume that this function is admissible (which is true).

(a) Find out what count does, e.g. by evaluating count on some input
values, including the following:

(count 1 6 0) = 16

Now conjecture a closed formula (one whose evaluation does not require
recursion) for (count i j c):

phi: (natp i) /\ (natp j) /\ (natp c) => (count i j c) = 10i + j + c

(b) Prove conjecture phi using induction. Use the induction scheme suggested by count!

- (not ((natp i) /\ (natp j) /\ (natp c))) => phi
- (natp i) /\ (natp j) /\ (natp c) /\ i=j=0 => phi
- (natp i) /\ (natp j) /\ (natp c) /\ j>0 /\        (count i j-1 c+1) = 10  i   + (j-1) + (c+1) => phi
- (natp i) /\ (natp j) /\ (natp c) /\ i>0 /\ j=0 /\ (count i-1 9 c+1) = 10(i-1) +   9   + (c+1) => phi

All these are straightforward arithmetic. We omit the proofs here.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

2. Consider:

(defunc in (x l)
  :input-contract (listp l)
  :output-contract (booleanp (in x l))
  (cond ((endp l)            nil)
        ((equal x (first l)) t)
        (t                   (in x (rest l)))))

(defunc subsetp (l1 l2)
  :input-contract (and (listp l1) (listp l2))
  :output-contract (booleanp (subsetp l1 l2))
  (if (endp l1)
    t
    (and (in (first l1) l2)
         (subsetp (rest l1) l2))))

(defunc union (l1 l2)
  :input-contract (and (listp l1) (listp l2))
  :output-contract (listp (union l1 l2))
  (if (endp l1)
    l2
    (cons (first l1) (union (rest l1) l2))))

(defunc intersect (l1 l2)
  :input-contract (and (listp l1) (listp l2))
  :output-contract (listp (intersect l1 l2))
  (cond ((endp l1)          nil)
        ((in (first l1) l2) (cons (first l1) (intersect (rest l1) l2)))
        (t                  (intersect (rest l1) l2))))

(a) Prove the following theorem.

phi_a: (listp l1) /\ (listp l2) => (subsetp l1 (union l1 l2))

We will use the induction scheme suggested by (len l1).

- (not (listp l1)) => phi_a: trivial
- (endp l1) => phi_a : trivial

(consp l1) /\ ((listp (rest l1)) /\ (listp l2) => (subsetp (rest l1) (union (rest l1) l2)))
  => ((listp l1) /\ (listp l2) => (subsetp l1 (union l1 l2)))

We need a lemma: (and (listp x) (listp y)) => ((subsetp x y) => (subsetp x (cons a y)))     (*)

C1. (consp l1)
C2. (listp (rest l1)) /\ (listp l2) => (subsetp (rest l1) (union (rest l1) l2))
C3. (listp l1)
C4. (listp l2)

C5. (listp (rest l1)) { C1,C3 }
C6. (subsetp (rest l1) (union (rest l1) l2)) { C2,C5,C4,MP }
C7. (subsetp (rest l1) (cons (first l1) (union (rest l1) l2)) { Modus Ponens on C6 and (*): ((x (rest l1)) (y (union (rest l1) l2)) (a (first l1))) }

  (subsetp l1 (union l1 l2))

= { def. subsetp, C1 }

  (in (first l1) (union l1 l2)) /\ (subsetp (rest l1) (union l1 l2))

= { def. union, C1 }

  (in (first l1) (cons (first l1) (union (rest l1) l2))) /\ (subsetp (rest l1) (cons (first l1) (union (rest l1) l2)))

= { def. in, axioms cons, first }

  (subsetp (rest l1) (cons (first l1) (union (rest l1) l2)))

= { C7 }

  t

(b) Prove the following theorem.

phi_b: (listp l1) /\ (listp l2) /\ (subsetp l1 l2) => (intersect l1 l2) = l1

We will use the induction scheme suggested by intersect:

- (endp l1) => phi_b: trivial

- (consp l1) /\ (in (first l1) l2) /\ ((subsetp (rest l1) l2) => (intersect (rest l1) l2) = (rest l1))
  => ((subsetp l1 l2) => (intersect l1 l2) = l1)

C1. (consp l1)
C2. (in (first l1) l2)
C3. (subsetp (rest l1) l2) => (intersect (rest l1) l2) = (rest l1)
C4. (subset l1 l2)

C5. (subset (rest l1) l2)                { def. subset, C1, C4 }
C6. (intersect (rest l1) l2) = (rest l1) { MP }

  (intersect l1 l2)

= { def. intersect }

  (cons (first l1) (intersect (rest l1) l2))

= { C6 }

  (cons (first l1) (rest l1))

= { axioms first, rest, cons }

  l1

- (consp l1) /\ (not (in (first l1) l2)) /\ ((subsetp (rest l1) l2) => (intersect (rest l1) l2) = (rest l1))
  => ((subsetp l1 l2) => (intersect l1 l2) = l1)

C1. (consp l1)
C2. (not (in (first l1) l2))
C3. (subsetp (rest l1) l2) => (intersect (rest l1) l2) = (rest l1)
C4. (subset l1 l2)

C5. (in (first l1) l2) { def. (subset l1 l2) }
C6. nil                { C2, C5 }

(c) Prove the following theorem.

phi_c: (listp l1) /\ (listp l2) /\ (subsetp l1 l2) => (intersect l1 (union l1 l2)) = l1

We will use the induction scheme suggested by listp.

- (endp l1) => phi_c: trivial

- (consp l1) /\ ((subsetp (rest l1) l2) => (intersect (rest l1) (union (rest l1) l2)) = (rest l1))
  => (subsetp l1 l2) => (intersect l1 (union l1 l2)) = l1

C1. (consp l1)
C2. (subsetp (rest l1) l2) => (intersect (rest l1) (union (rest l1) l2)) = (rest l1)
C3. (subsetp l1 l2)

C4. (subsetp (rest l1) l2) { C3, def. subsetp }
C5. (intersect (rest l1) (union (rest l1) l2)) = (rest l1) { MP }
C6. (subsetp l1 (union l1 l2))   { phi_a }
C7. (subsetp l1 (union l1 l2)) => (intersect l1 (union l1 l2)) = l1 { phi_b: ((l2 (union l1 l2))) }
C8. (intersect l1 (union l1 l2)) = l1 { MP }

  (intersect l1 (union l1 l2))

= { C8 }

  l1

|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Vagueness of Specifications
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|

3. In this problem you will be using the acl2::test? mechanism. This
function takes a conjecture as input and runs a number of tests to see
whether it can find a counterexample. For example, let us conjecture that,
for positive natural numbers x and y, (x + y) and (x * y) are different.
You can test this conjecture like this:

(acl2::test? (implies (and (posp x) (posp y)) (not (equal (+ x y) (* x y)))))

Test? may report that it succeeded: no counterexamples were found. This
does not mean you have proved the conjecture. It just means test? hasn't
come across a test that falsifies it. In fact, the above conjecture is
wrong. You can try to find more counterexamples by increasing the number of
tests run, like this:

(acl2::acl2s-defaults :set acl2::num-trials 200)

Now try test? again.

In general, make sure to perform conjecture contract checking before
passing your conjecture to acl2::test? . For example,

(acl2::test? (equal (app x y) (app y x)))

will waste time running many useless tests in which x and y are not
lists, and report contract violations. In contrast,

(acl2::test? (implies (and (listp x) (listp y)) (equal (app x y) (app y x))))

will return a counterexample using lists immediately.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Suppose you are asked to write a function that computes the union of two
sets, where a set is represented using a list. The union of two sets
consists of all elements that are contained in at least one of the input
sets. Consider the following definitions.

(defdata set (listof all))

(defunc union1 (s1 s2)
  :input-contract (and (setp s1) (setp s2))
  :output-contract (setp (union1 s1 s2))
  (app s1 s2))

(defunc union2 (s1 s2)
  :input-contract (and (setp s1) (setp s2))
  :output-contract (setp (union2 s1 s2))
  (app (rev s1) (rev s2)))

(defunc union3 (s1 s2)
  :input-contract (and (setp s1) (setp s2))
  :output-contract (setp (union3 s1 s2))
  (if (endp s2)
      s1
    (cons (first s2) (union3 s1 (rest s2)))))

(defunc union4 (s1 s2)
  :input-contract (and (setp s1) (setp s2))
  :output-contract (setp (union4 s1 s2))
  (if (or (endp s1) (endp s2))
      nil
    (cons (first s1) (cons (first s2) (union4 (rest s1) (rest s2))))))

Note that all definitions union[1-4] have the same signature and input and
output contracts.

(a) Prove that these four solutions are pairwise different. That is, for
each pair of functions union[1-4] , find an input (s1 s2) on which the two
functions produce different output. You therefore need to produce 6
examples (there are 6 pairs). Consider using test? as an assistant.

The inputs can be found using the following tests:
(acl2::test? (implies (and (setp s1) (setp s2)) (equal (union1 s1 s2) (union2 s1 s2))))
(acl2::test? (implies (and (setp s1) (setp s2)) (equal (union1 s1 s2) (union3 s1 s2))))
(acl2::test? (implies (and (setp s1) (setp s2)) (equal (union1 s1 s2) (union4 s1 s2))))
(acl2::test? (implies (and (setp s1) (setp s2)) (equal (union2 s1 s2) (union3 s1 s2))))
(acl2::test? (implies (and (setp s1) (setp s2)) (equal (union2 s1 s2) (union4 s1 s2))))
(acl2::test? (implies (and (setp s1) (setp s2)) (equal (union3 s1 s2) (union4 s1 s2))))

(b) Function union1 satisfies the specification "union of two sets" given
above: "The union of two sets consists of..." (you don't need to prove
that). What about the others? For union2, union3, union4, if you suspect it
does, say so. If you suspect it doesn't, give a counterexample (how you
find it is up to you).

union2, union3 are correct.
union4 is wrong; CEX: (union4 nil '(1)) = nil

(c) For each of the functions identified under (b) to _fail_ the union
specification, let's see whether we can say more. Use test? to test the
following conjectures:

(in x (union1 s1 s2)) => (in x (union? s1 s2))
(in x (union? s1 s2)) => (in x (union1 s1 s2))

where union? is one of the functions identified in (b) to fail the
specification (and union1 is the first function, which is known to satisfy
the specification).

What do these conjectures state? Formulate in English.

The first conjecture states that (union1 s1 s2) is a subset of (union? s1 s2)
The second states the converse.

For your testing, remember to perform conjecture contract checking, and add
proper hypotheses. We are not interested in contract violations.

If ACL2s can't find a counterexample, make it try harder by adjusting the
number of trials.

 (acl2::test? (implies (and (setp s1) (setp s2) (in x (union1 s1 s2))) (in x (union4 s1 s2))))
 (acl2::test? (implies (and (setp s1) (setp s2) (in x (union4 s1 s2))) (in x (union1 s1 s2))))

(d) You have identified in (b) a number of functions to _satisfy_ the union
specification, but according to (a) they are still different. Let's see
whether we can be more precise. Formulate a conjecture about the
relationship of the result returned by union1 (which is "correct") and any
of the other functions deemed to be "correct". Of course, one such
conjecture is that they all implement "union". We are looking for a more
precise conjecture that looks at the representation of the "union" as a
list of elements.

For extra credit, write functions that allow you to test your conjecture
using test?.

Functions union1,2,3 are identical up to permutations of the output list.

|#
